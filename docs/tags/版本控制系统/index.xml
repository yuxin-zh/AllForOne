<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>版本控制系统 on AllForOne&#39;s Site,Young genneration comes!</title>
    <link>https://yuxin-zh.github.io/AllForOne/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</link>
    <description>Recent content in 版本控制系统 on AllForOne&#39;s Site,Young genneration comes!</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Feb 2022 00:01:02 +0800</lastBuildDate>
    <atom:link href="https://yuxin-zh.github.io/AllForOne/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Git</title>
      <link>https://yuxin-zh.github.io/AllForOne/p/git/</link>
      <pubDate>Tue, 15 Feb 2022 00:01:02 +0800</pubDate>
      <guid>https://yuxin-zh.github.io/AllForOne/p/git/</guid>
      <description>&lt;p&gt;[TOC]&lt;/p&gt;&#xA;&lt;h1 id=&#34;git&#34;&gt;Git&lt;/h1&gt;&#xA;&lt;h2 id=&#34;1版本控制系统vcs&#34;&gt;1.版本控制系统（VCS)&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-基本概念----行内代码&#34;&gt;1.1 基本概念    &lt;code&gt;...&lt;/code&gt;行内代码&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;版本控制系统（VCS）最基本的功能就是版本控制。而所谓版本控制，意思就是在文件的修改历史中保存修改历史，让i方便对文件的i修改工作。&lt;/li&gt;&#xA;&lt;li&gt;我们常用的主流文本编辑器的undo功能其实就是版本控制。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;但是VCS和文本编辑器的撤销功能相比，有一个很重要的区别就是：&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于程序代码而言：修改的生命周期很长，如果采用每次改动自动保存的形式来保存修改历史，将会导致改动历史非常频繁和无章可循。所以和文本编辑器的撤销功能不同，VCS保存修改历史，使用的是&lt;strong&gt;主动提交改动&lt;/strong&gt;的机制。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2分布式版本控制系统dvcs&#34;&gt;2.分布式版本控制系统(DVCS)&lt;/h2&gt;&#xA;&lt;h3 id=&#34;21-工作模型&#34;&gt;2.1 工作模型&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分布式（DVCS）与VCS的区别在于，分布式VCS除了中央仓库之外，还有本地仓库：团队的每一个成员的机器上都有一份本地昂库，这个仓库包含了所有版本历史，换句话说在这种工作模型内，你是和本地仓库交互。&lt;/li&gt;&#xA;&lt;li&gt;工作流程&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提交代码到本地仓库&lt;/li&gt;&#xA;&lt;li&gt;在服务器上创建一个中央仓库，并把1中的提交推送到服务器的中央仓库。&lt;/li&gt;&#xA;&lt;li&gt;其他工作人员将中央仓库的所有内容克隆到本地，拥有了各自的本地仓库，此时进行并行开发&lt;/li&gt;&#xA;&lt;li&gt;在职过后的开发过程中，么个人都会独立负责开发一个功能，在这个功能的开发过程中，每个人都会把它的每一步改动提交到本地仓库（由于本地提交毋须立即推送到中央仓库，所以提交的内容不一定要是一个完整的功能额模块，而可以是某个步骤）&lt;/li&gt;&#xA;&lt;li&gt;当完成了某个功能的开发时，可以把与该功能相关的所有提交 &lt;strong&gt;从本地仓库推送到中央仓库&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;而每次有人把新的提交推送到中央仓库是，另外的人就可以选择把这些提交同步到自己的机器上，并把他们和自己的本地代码合并&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;22优缺点分析&#34;&gt;2.2优缺点分析&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;😵优点：①大多数操作可以在本地运行，速度更快。②由于可以提交到本地，因此可以分步提交代码，把代码提交做的更细，而不是一个提交包含很多代码，难以review也难以回溯。&lt;/li&gt;&#xA;&lt;li&gt;🤠缺点：由于每一个旧机器都需要有完整的本地仓库，所以初次获取代码需要获取项目比较费时②本地占用的存储比中央式高&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;3使用git管理代码&#34;&gt;3.使用Git管理代码&lt;/h2&gt;&#xA;&lt;h3 id=&#34;31-前期准备&#34;&gt;3.1 前期准备&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Github创建远程仓库 （.gitignore设置项目类型，是git仓库中的一个特俗的文本文件，记录了你不希望提交到仓库的目录和文件的名称或类型&lt;/li&gt;&#xA;&lt;li&gt;点击右边的Clone or downloda，然后把仓库的Clone地址复制到截切版&lt;/li&gt;&#xA;&lt;li&gt;在你喜欢的任意一个位置，打开Git Bash,&lt;strong&gt;输入Git clone 刚复制的地址&lt;/strong&gt;（该过程可能会需要你去输入Github的用户名和密码）&lt;/li&gt;&#xA;&lt;li&gt;克隆完毕后，你的目录中会出现.git的隐藏目录，改了目录就是你的本地仓库，你的所有把那本信息都会存在这里。而.git所在的目录成为工作目录。&lt;/li&gt;&#xA;&lt;li&gt;一些git的基本指令在这里就不详细介绍了，可以查阅Git官方文档&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;4git基本工作模型&#34;&gt;4.Git基本工作模型&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;由于git在工作时，必须保证自己的本地仓库与中央仓库保持一致，因此，当你第一次从中央仓库拉去代码后，你的同事又push了一次，那么当你想要把自己的commits提交上去时，就需要先拉取同事的代码到本地。😧&lt;/li&gt;&#xA;&lt;li&gt;当push时出现冲突：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在现实的团队开发中，全队时同时并行开发的，所以必然会出现当一人push代码时，中央仓库已经被其他同事先一步push了的情况。&lt;/li&gt;&#xA;&lt;li&gt;那这种情况下，当我们像上面介绍的那样使用git pull指令拉取代码时，他并不会像之前那样直接结束，而是会出现一个输入提交信息的界面，这是因为pull操作返现不仅远程仓库有本地每天有的commits，本地也有远端仓库不具备的commits，它就会把远端和本地独有的commit合并，自动生成一个新的commit&lt;/li&gt;&#xA;&lt;li&gt;另一种情况，当出现冲突的部分是你和你的同事对某一个文件的某一处进行了不同的修改，Git就无法直接处理了，关于这点会在之后的文章中介绍🦄&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;5headmasterbranch的使用讲解&#34;&gt;5.Head、master、branch的使用讲解&lt;/h2&gt;&#xA;&lt;p&gt;👇👇👇👇👇👇👇👇👇👇👇👇&lt;/p&gt;&#xA;&lt;p&gt;When Typed &amp;ldquo;git log&amp;rdquo;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://s2.loli.net/2022/02/14/nUwiuFzc2vDJ13g.png&#34; alt=&#34;image-20220210161411687.png&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;第一行的commit后面的括号里的 &lt;em&gt;HEAD-&amp;gt; main&lt;/em&gt;，是只想这个commit的引用。在Git操作中，经常会需要对指定Commit进行操作，而每一个Commit都会有它唯一的指定方式——它的SHA-1校验和，也就是每个commit中那串黄色的字符。由于SHA-1重复的概率极低，因此你可以使用它来指代某一个commit，也可以只是用他的前几位来指代。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Head ：当前的Commit的引用：也就是说当前工作目录所对应的Commit。All in all,Commit在哪里，Head就在哪里。、&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Branch：是Git中的另一个引用，Head除了可以指向commit，还可以指branch；当他指向branch时，会通过这个branch来简介地指向某个commit；Besides:person_frowning:当Head在提交时自动向前移动时，它会带着它所指向地Branch一起移动。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如上图 HEAD-&amp;gt;main,main就是当前分支的名字。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://s2.loli.net/2022/02/14/9xeTpcd86Zky72Q.png&#34; alt=&#34;image-20220210162748358.png&#34;&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;&#xA;&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1&#xA;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&#xA;&lt;td class=&#34;lntd&#34;&gt;&#xA;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;当你输入Git commit,Head就会带着这个分支，移向下一个commit&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://s2.loli.net/2022/02/14/BWpratdZP3NOhJM.png&#34; alt=&#34;image-20220210162916120.png&#34;&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;你可以通过git log指令 对这个逻辑进行验证，这里就不详细说明了&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
